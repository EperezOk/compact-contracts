pragma language_version >= 0.14.0;

import CompactStandardLibrary;

export struct TokenMetadata {
  name: Maybe<Opaque<"string">>,
  symbol: Maybe<Opaque<"string">>,
  decimals: Uint<8>
}

export { CoinInfo, ZswapCoinPublicKey, ContractAddress };

//
// State
//

// These should most likely not be exportable.
// Instead, we should rely on setters/getters to read/write state.
// Keeping them exportable for now to maintain simplicity.
export ledger counter: Counter;
export ledger nonce: Bytes<32>;
export ledger supply: Uint<128>;
export sealed ledger domain: Bytes<32>;
export sealed ledger metadata: TokenMetadata;

constructor(
  initNonce: Bytes<32>,
  tokenMetadata: TokenMetadata
) {
  nonce = initNonce;
  const _domain = pad(32, "ERC20");
  domain = _domain;
  metadata = tokenMetadata;
}

/// Returns the name of the token.
export circuit name(): Maybe<Opaque<"string">> {
  return metadata.name;
}

/// Returns the ticker of the token.
export circuit symbol(): Maybe<Opaque<"string">> {
  return metadata.symbol;
}

/// Returns the number of decimals used to get its user representation.
export circuit decimals(): Uint<8> {
  return metadata.decimals;
}

/// Returns the value of tokens in existence.
export circuit totalSupply(): Uint<256> {
  return supply;
}

/// For testing
export circuit mintToCaller(amount: Uint<128>): [] {
  const caller = own_public_key();
  mint(left<ZswapCoinPublicKey, ContractAddress>(caller), amount);
}

/// Mints `amount` tokens to `recipient`.
/// This circuit does not include access control meaning anyone call it if exported.
export circuit mint(recipient: Either<ZswapCoinPublicKey, ContractAddress>, amount: Uint<128>): [] {
  counter.increment(1);
  const newNonce = evolve_nonce(counter, nonce);
  mint_token(domain, amount, newNonce, recipient);
  nonce = newNonce;
  supply = supply + amount as Uint<128>;
}

/// Destroys `amount` of `coin` by sending it to `burn_address`.
/// This circuit does not include access control meaning anyone can call it if exported.
export circuit burn(coin: CoinInfo, amount: Uint<128>): [] {
  assert coin.color == token_type(domain, kernel.self()) "Token not created from this contract";
  assert coin.value >= amount "Insufficient funds to burn";

  receive(coin);
  supply = supply - amount;

  const res = send_immediate(coin, burn_address(), amount);
  if (res.change.is_some) {
    // tmp for only zswap because we should be able to handle contracts burning tokens
    // and returning change.
    const tmpAddr = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
    send_immediate(res.change.value, tmpAddr, res.change.value.value);
  }
}

/// Transfers `amount` tokens from this contract to `recipient`.
/// This circuit does not include access control meaning anyone can call it if exported.
export circuit transfer(recipient: Either<ZswapCoinPublicKey, ContractAddress>, amount: Uint<128>): [] {
  // send();
}
