pragma language_version >= 0.14.0;

import CompactStandardLibrary;

export { ZswapCoinPublicKey, ContractAddress, Either, Maybe };

/// Public state
export sealed ledger name: Maybe<Opaque<"string">>;
export sealed ledger symbol: Maybe<Opaque<"string">>;
export sealed ledger decimals: Uint<8>;
export ledger totalSupply: Uint<256>;
export ledger balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<256>>;
export ledger allowances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<256>>>;

/**
 * @description Initializes the contract.
 *
 * @param _name - The name of the token.
 * @param _symbol - The symbol of the token.
 * @param _decimals - The number of decimals used to get the user representation.
 */
constructor(
  _name: Maybe<Opaque<"string">>,
  _symbol: Maybe<Opaque<"string">>,
  _decimals:Uint<8>
) {
  name = _name;
  symbol = _symbol;
  decimals = _decimals;
}

/**
 * @description Returns the value of tokens owned by `account`.
 *
 * @dev Manually checks if `account` is a key in the map and returns 0 if it is not.
 *
 * @param account - The public key or contract address to query.
 * @return Uint<256> - The account's token balance.
 */
export circuit balanceOf(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<256> {
  if (!balances.member(account)) {
    return 0;
  }

  return balances.lookup(account);
}

/**
 * @description Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner`
 *              through `transferFrom`. This value changes when `approve` or `transferFrom` are called.
 *
 * @dev Manually checks if `owner` and `spender` are keys in the map and returns 0 if they are not.
 *
 * @param owner - The public key or contract address of approver.
 * @param spender - The public key or contract address of spender.
 * @return Uint<256> - The `spender`'s allowance over `owner`'s tokens.
 */
export circuit allowance(
  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  spender: Either<ZswapCoinPublicKey, ContractAddress>
): Uint<256> {
  if (!allowances.member(owner) || !allowances.lookup(owner).member(spender)) {
    return 0;
  }

  return allowances.lookup(owner).lookup(spender);
}

export circuit transfer(to: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<256>): Boolean {
  // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
  const owner = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
  _transfer(owner, to, value);
  return true;
}

export circuit transferFrom(
  from: Either<ZswapCoinPublicKey, ContractAddress>,
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  value: Uint<256>
): Boolean {
  // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
  const spender = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
  _spendAllowance(from, spender, value);
  _transfer(from, to, value);
  return true;
}

export circuit approve(spender: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<256>): Boolean {
  // TMP - Waiting for contract-to-contract calls to handle `right` with contract address
  const owner = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
  _approve(owner, spender, value);
  return true;
}

export circuit _approve(
  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  spender: Either<ZswapCoinPublicKey, ContractAddress>,
  value: Uint<256>
): [] {
  assert !_isZero(owner) "ERC20: invalid owner";
  assert !_isZero(spender) "ERC20: invalid spender";
  allowances.lookup(owner).insert(spender, value);
}

export circuit _transfer(
  from: Either<ZswapCoinPublicKey, ContractAddress>,
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  value: Uint<256>
): [] {
  assert !_isZero(from) "ERC20: invalid sender";
  assert !_isZero(to) "ERC20: invalid receiver";

  _update(from, to, value);
}

export circuit _mint(
  account: Either<ZswapCoinPublicKey, ContractAddress>,
  value: Uint<256>
): [] {
  assert !_isZero(account) "ERC20: invalid receiver";
  // Using the contract variant of 0
  // TODO: Look into if this matters
  const zero_address = right<ZswapCoinPublicKey, ContractAddress>(ContractAddress{ pad(32, "") });

  _update(zero_address, account, value);
}

export circuit _burn(
  account: Either<ZswapCoinPublicKey, ContractAddress>,
  value: Uint<256>
): [] {
  assert !_isZero(account) "ERC20: invalid sender";
  // Using the contract variant of 0
  // TODO: Look into if this matters
  const zero_address = right<ZswapCoinPublicKey, ContractAddress>(ContractAddress{ pad(32, "") });
  _update(account, zero_address, value);
}

export circuit _update(
  from: Either<ZswapCoinPublicKey, ContractAddress>,
  to: Either<ZswapCoinPublicKey, ContractAddress>,
  value: Uint<256>
): [] {
  if (_isZero(from)) {
    // Mint
    totalSupply = totalSupply + value as Uint<256>;
  } else {
    const fromBal = balanceOf(from);
    assert fromBal > value "ERC20: insufficient balance";
    balances.insert(from, fromBal - value);
    }

  if (_isZero(to)) {
    // Burn
    totalSupply = totalSupply - value as Uint<256>;
  } else {
    const toBal = balanceOf(to);
    if (toBal == 0) {
      balances.insert(to, value);
    } else {
      balances.insert(to, toBal + value as Uint<256>);
    }
  }
}

export circuit _spendAllowance(
  owner: Either<ZswapCoinPublicKey, ContractAddress>,
  spender: Either<ZswapCoinPublicKey, ContractAddress>,
  value: Uint<256>
): [] {
  const currentAllowance = allowances.lookup(owner).lookup(spender);
  // TODO: improve readability of max_u256
  const max_u256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
  if (currentAllowance < max_u256) {
    assert currentAllowance > value "ERC20: insufficient allowance";
    _approve(owner, spender, currentAllowance - value as Uint<256>);
  }
}

export pure circuit _isZero(keyOrAddress: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
  const zero = pad(32, "");

  if (keyOrAddress.is_left) {
    return keyOrAddress == left<ZswapCoinPublicKey, ContractAddress>(ZswapCoinPublicKey{ zero });
  } else {
    return keyOrAddress == right<ZswapCoinPublicKey, ContractAddress>(ContractAddress{ zero });
  }
}
